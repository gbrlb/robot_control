\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{mathtools}

\usepackage{setspace}
\onehalfspacing
\usepackage{subcaption}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{indentfirst}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{corollary}{Corollary}

\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{example*}{Example}
\newtheorem*{definition*}{Definition}
\newtheorem*{remark*}{Remark}
\newtheorem*{corollary*}{Corollary}

%\usepackage{booktabs, caption, graphicx, float}
%\usepackage{subcaption}
%\captionsetup{tableposition=top,figureposition=bottom,font=small}

\usepackage{comment}
\usepackage{multirow}
\usepackage{array}

\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage[hidelinks]{hyperref}

\usepackage{geometry}
\geometry{a4paper, top=3cm,bottom=3cm,left=3cm,right=3cm,%
			heightrounded}
\usepackage{upgreek}
\usepackage{xparse}
\usepackage{listings}
\NewDocumentCommand{\codeword}{v}{%
	\texttt{\textcolor{black}{#1}}%
}

\newcommand{\prepos}[3]{${}_{\mathbf{#2}}{\mathbf{#1}}_{#3}$}
\newcommand{\preposm}[3]{{}_{\mathbf{#2}}{\mathbf{#1}}_{#3}}


%Dummy text
\usepackage{lipsum}

%Changing headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{\textit{\thepage}}
\lhead{\textit{Kinematics and Dynamics Lab}}

%For inserting the code
\usepackage{fancyvrb}

%For bold math symbols
\usepackage{bm}

%For multicolumns
\usepackage{multicol}

% Norm and abs delimiter
\usepackage{mathtools}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiterX{\norm}[1]{\lVert}{\rVert}{#1}

\setcounter{section}{-1}

% Argmin/Argmax
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

% Enumerate
\usepackage{enumitem}

% Code
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{etoolbox}

% Longtable
\usepackage{longtable}

% SI units
\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}

% Colours in equations
\usepackage{xcolor}

\title{LAB 1: Kinematics and Dynamics Lab: Simulation of a 4-DoF Serial Manipulator}
\author{Michele Focchi and Octavio Villarreal \\
Edited by Thiago Boaventura}
\date{}

\begin{document}
\maketitle
\noindent
The goals of this assignment are:
\begin{itemize}
    \item learning the basic procedure to visualize a robot model using the Unified Robot Description Format (URDF)
    \item compute and visualize the direct/inverse kinematics of a 4-DoF serial manipulator 
    \item compute and analyze the forward/inverse dynamics of a 4-DoF serial manipulator using the Recursive Newton-Euler Algorithm (RNEA)
\end{itemize}

\noindent
Tools that we are going to be using in this lab (all open-source):
\begin{itemize}
	\item Python programming (2.7)\footnote{https://docs.python.org/2.7/}
	\item Robot Operating System (ROS)\footnote{https://www.ros.org/}
	\item Pinocchio Library for Rigid Body Dynamics Algorithms\footnote{https://github.com/stack-of-tasks/pinocchio}
	\item Locosim\footnote{https://github.com/mfocchi/locosim}
\end{itemize}
%
%
%\noindent
In this assignment, we will simulate the behavior of a 4-DoF anthropomorphic robot manipulator under zero-torque at the joints (i.e., free-falling under the effect of gravity which is the only force making work on the robot). Initially, we will learn how to describe a robot using the URDF convention, such that ROS is able to "understand" and visualize our robot using the visualizer tool in RVIZ.\footnote{https://dl.acm.org/doi/abs/10.1007/s11235-015-0034-5} Secondly, we will proceed to develop code in Python to compute the direct and inverse kinematics functions of  our robot manipulator and we will design a simple trajectory for our robot to follow based on polynomials. Finally, we will write functions to compute both the forward (to simulate) and the inverse dynamics (to control) of our robot manipulator using the RNEA.  Based on RNEA, we will compute separately each of the terms of the dynamics equation ($\mathbf{M}$, $\mathbf{h}$ and $\mathbf{g}$) and perform analysis on them. For both the kinematics and dynamics parts, we will compare our results with the built-in functions of the Pinocchio library to verify the correctness of our computations.

%
\section{Preliminaries}
We are going to be using functions and interfaces written in the locosim package installed in the provided virtual machine (VM) for the course. Locosim is stored as a github\footnote{https://git-scm.com/} repository, and we have created a branch containing the files needed for this lab, but we need to get them in our VM to do so, follow these steps:

\begin{enumerate}
	\item Open a new terminal inside of the VM (either by clicking on the icon of the launcher on the left or by hitting the keyboard shortcut \codeword{Ctrl + Alt + T})
	\item In the terminal type the following commands
	
	\begin{verbatim}
		cd ros_ws/src/locosim/
		git fetch 
		git checkout master
		git submodule update --init --recursive
		cd ~/ros_ws
		catkin_make install
		source ~/.bashrc
	\end{verbatim}

	\item Additionally we have to install a tool to interactively change the values of the joints by typing the following commands:
	\begin{verbatim}
		sudo apt update
		sudo apt install ros-kinetic-joint-state-publisher-gui
	\end{verbatim}
\end{enumerate}
%
\section{Robot URDF description file and visualization}
%
In this part of the lab we are going to visualize our 4-DoF manipulator using the previously mentioned software tools.

\textbf{1.1 Basic geometry description.} Go to the folder that contains the files corresponding the robot description by typing the following commands on the terminal:
\begin{verbatim}
	cd ~/ros_ws/src/locosim/robot_urdf
\end{verbatim}
Let's start by inspecting a file that describes a robot made of regular geometries (cubes and cylinders). Type on the terminal:
\begin{verbatim}
	gedit simple_geometry.urdf
\end{verbatim}

As mentioned, a robot is described in robot using a URDF file, which is scripted using the metalanguage \codeword{xml}, and specific \codeword{xml} macros (i.e., \codeword{xacro}). We can both use the extension \codeword{*.urdf} or \codeword{*.xacro}, however, when dealing with large models a combination of both might be required since \codeword{xacro} files allowed for modularity, but some CAD software outputs directly a \codeword{urdf} file. In general, you use \codeword{xacro}  to assemble  parametrized \codeword{urdf}  of the subparts of a robot. For instance in the case of a legged robot, you can define the  \codeword{urdf} for a generic leg and parametrize it with its location along the trunk, without copying and pasting code. However, in this class, we will not use this feature and you will find only \codeword{urdf} files in the folder. 
Inspect the \textit{simple\_geometry} file and try to understand what each line describes. How are the links described? Which parameters need to be described per link? How are joints defined? Is there a "special" link?

\textbf{1.2 Use an stl mesh file to describe a link.} We can use .stl files to specify the geometry of the link instead of using basic geometries such as a cilinder or a block. The .stl format is a common extension used in CAD softwares such as SolidWorks to store rigid parts of a mechanical design. However, when using stl files, one needs to be careful to not use an excessive number of polygons to describe the part, since this might cause the simulation to slow down significantly. The file \codeword{ur4_2links.urdf} contains to links associated to a mesh stl file. Inspect the \codeword{ur4_2links.urdf} by typing in the terminal (you can either open a new terminal or kill the process in the previous one by hitting \codeword{Ctrl + C})
%
\begin{verbatim}
	gedit ur4_2links.urdf
\end{verbatim}
%
You will notice that the file contains more details and parameters per link and joint. What can they represent? Where are these values obtained from? Are they referred to a specific reference frame?

\textbf{1.3 Visualizing a model described by a URDF in RVIZ.} The basic unit of development in ROS is the node. A node is nothing else than a process that performs computations. It can be created in multiple languages and interfaces such as Python and C++. Nodes communicate through messages by either using a publisher-subscriber (asynchronous)\footnote{http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(python)} or a request-reply (synchronous)\footnote{http://wiki.ros.org/ROS/Tutorials/WritingServiceClient(python)} scheme. In this lab session we will use the former one, and locosim already provides a dedicated function to publish the state of the joints during runtime and make them available to the visualizer node running RVIZ. One can run each node separately using the terminal command \codeword{rosrun}\footnote{http://wiki.ros.org/rosbash\#rosrun}, however, a more convenient way is to setup a launch file and run multiple nodes with only with terminal command (namely, \codeword{roslaunch}\footnote{http://wiki.ros.org/roslaunch}). Let us inspect the launch file to visualize our examples of URDF files. In a terminal type:
%
\begin{verbatim}
	cd ~/ros_ws/src/locosim/ros_impedance_controller/launch
	gedit visualize.launch
\end{verbatim}
%
Inspect each line of the file and try to understand the function of each 
of the tags. Check how the rigid (homogeneous) transform is set for the \textit{shoulder\_pan\_joint}  with respect to the supporting \textit{base\_link}. Check also how the dynamic parameters (mass, center of mass, and inertia tensor) are defined for the link, with respect to the link frame. Once the file has been inspected,  run the following command in the terminal:

\footnotesize
\begin{verbatim}
	roslaunch ros_impedance_controller visualize.launch robot_name:=simple_geometry test_joints:=true
\end{verbatim}

\normalsize
You will see the model constructed by using regular geometries. You can play around with the value of the only joint (shoulder\_pan\_joint) present in the model, using the slider input in the GUI. It is possible to visualize the link frames, adding the TF plugin in RVIZ. Stop the process by hitting \codeword{Ctrl + C} in the terminal in which you ran the previous launch file. 
Note that we need to add a \textit{trasmission} for the joint if we want to be able to control it. 
Now let us visualize a one-joint two-link manipulator by typing the following command:
%
%
\footnotesize
\begin{verbatim}
	roslaunch ros_impedance_controller visualize.launch robot_name:=ur4_2links test_joints:=true
\end{verbatim} 
%
\normalsize
Again, you will visualize the described model and you can modify the value of the joint to make the shoulder link move. To finalize this exercise, let us visualize the 4-DoF robot manipulator that we will use in the next two parts of this lab session and visualize its joint motions. Stop the process in the terminal and then run the following command:
%
%
\footnotesize
\begin{verbatim}
	roslaunch ros_impedance_controller visualize.launch robot_name:=ur4_robot test_joints:=true
\end{verbatim} 
\normalsize
Note that we did not have to specify the robot since \codeword{ur4_robot} is the default value of the argument \codeword{robot_name}. This will launch RVIZ and it will allow us to move around all four joints of our manipulator.

\textbf{1.4 ROS topics.} So far we have only mentioned that a node can publish a message, but where is this message "published to"? Messages are published to \textit{topics}, and this makes them available to other nodes that can \textit{subscribe} to a specific topic. In our case, our launch file (\codeword{visualize_ur4.launch}), runs a node called \codeword{joint_state_publisher}, which is in charge, as its name indicates, to publish the joint values on to the topic \codeword{joint_state}. Let's verify this, run again (in case you have stopped it) the command from the previous step and in a separate terminal run the following command:
\begin{verbatim}
	rostopic echo /joint_states
\end{verbatim}
This will give a series of information about the \codeword{joint_states} topic, including the name and value for each of the joints of our manipulator. Change the values using the GUI and verify that the values of the joints are changing. In essence, the \codeword{joint_state_publisher} node is publishing the value of the joints on to the \codeword{joint_states} topic and the node running RVIZ subscribes to this topic to display it in the visualizer.

\section{Robot kinematics}
Once the model visualization is finished, we now proceed to derive and analyze the robot kinematics. In this part, we will manually compute the direct and inverse kinematics computations and verify their correctness using the built-in Pinocchio functions. We will perform this computation using the Python interface of Locosim. 

\textbf{2.0 Setting up PyCharm and main files.} Open PyCharm from a terminal\footnote{It is very important to run it from a terminal, since the environment variables defined in the \textasciitilde/.bashrc file need to be loaded in order for ROS to find the location of the packages} by running the following command:
%
\begin{verbatim}
	pycharm-community
\end{verbatim}
%
Once PyCharm is opened, go to \codeword{File} and then \codeword{Open...} and select the folder where locosim is located (\codeword{/home/student/ros_ws/src/locosim}, and referred to as \codeword{LOCOSIM} from now on). To verify that everything is working properly, open the file \codeword{L1_Fixed_base_joint_} \codeword{space_control.py} inside of the \codeword{robot_control} and hit \codeword{Ctrl + Shift + F10}. You should see the manipulator going up and down. 
Verify that the interpreter is set to Python 2.7 (File/Settings/Project Interpreter).
This file was just for testing and we will use that in  the next lab session.
%
%
For this part of the assignment, we will use these three main files: 
\begin{itemize}
	\item \codeword{LOCOSIM/robot_control/L1_1_kinematics.py} (Main file to run the visualization)
	\item \codeword{LOCOSIM/robot_control/ex_1_conf.py} (Initializations of variables and simulaion parameters)
	\item \codeword{LOCOSIM/robot_control/base_controller/utils/kin_dyn_utils.py} (Kinematics and dynamics functions)
\end{itemize}
Inspect these files in detail. In this assignment you will try to write your own kinematics and dynamics functions of the file \codeword{kin_dyn_utils.py}.

\textbf{2.1 Direct kinematics (lecture E1).} The first step is to obtain the homogeneous transformation matrix from the world frame to the end-effector \prepos{T}{W}{e}. To do so, you will need to obtain the homogeneous transformation matrices from one link to the other (i.e., the local transformations \prepos{T}{W}{1}, \prepos{T}{1}{2}, \prepos{T}{2}{3}, \prepos{T}{3}{4} and \prepos{T}{4}{e}) and perform the composition of matrices. Modify the function \codeword{directKinematics} inside \codeword{kin_dyn_utils.py} to perform this computation. Hint: you can use the previously shown visualization tool to understand the changes in position and orientation of the different frames. You can call the function inside the package kin\_dyn\_utils.py from the main in the L3\_kinematics.py file. To verify the correctness of your direct kinematics function, compare it with the built-in functions from Pinocchio for the position vector (\codeword{robot.framePlacement(q, frame_ee).translation}) and the rotation matrix (\codeword{robot.framePlacement(q, frame_ee).rotation}) (as seen in the file \codeword{L3_kinematics.py}) using different values for the positions of the joints (changing \codeword{q0} in \codeword{L3_conf.py}).


\textbf{2.2 Geometric Jacobian (lecture E3).} Now that you have devised a function to compute the direct kinematics, proceed to to compute the end-effector Jacobian of the manipulator by modifying the function \codeword{computeEndEffectorJacobian} in \codeword{kin_dyn_utils.py}. Recall that the expression to compute the geometric Jacobian is:
\begin{equation*}
	\mathbf{J} = \begin{bmatrix}
		\mathbf{J}_{P1} & \dots & \mathbf{J}_{Pi} \\
		\mathbf{J}_{O1} & \dots & \mathbf{J}_{Oi}
	\end{bmatrix}
\end{equation*}

where
\begin{equation*}
	\begin{bmatrix}
		\mathbf{J}_{Pi}\\
		\mathbf{J}_{Oi}
	\end{bmatrix} = 
	\begin{cases}
		\begin{bmatrix}
			\mathbf{z}_i \\
			\mathbf{0}
		\end{bmatrix} \text{   if $i$ is prismatic} \\
		\\
		\begin{bmatrix}
			\mathbf{z}_i \times (\preposm{p}{W}{e} - \preposm{p}{W}{i}) \\
			\mathbf{z}_i
		\end{bmatrix}\text{   if $i$ is revolute}
	\end{cases}
\end{equation*}

In our case all of the joints are revolute. Recall as well that in this expression vector $\mathbf{z}_i$ represents the axis of joint $i$ that drives link $i$, expressed in the world frame. As in the previous case, compare your results with the built-in function of Pinocchio:
\codeword{robot.frameJacobian(q, frame_ee, False, pin.ReferenceFrame.LOCAL_WORLD_ALIGNED) } for different values of \codeword{q}.

\textbf{2.3 Analytical Jacobian (lecture E3).} Proceed to compute the analytical Jacobian $\mathbf{J}_r$ according to 
\begin{equation*}
	\mathbf{J}_r = \mathbf{T}_a \mathbf{J}
\end{equation*}
where $\mathbf{J}$ is the geometric Jacobian and $\mathbf{T}_a$ is the transformation matrix given by
\begin{equation*}
	\mathbf{T}_a = \begin{bmatrix}
		\mathbf{I} & \mathbf{0} \\
		\mathbf{0} & \mathbf{T}_{RPY}^{-1}
	\end{bmatrix}
\end{equation*}

where $\mathbf{T}_{RPY}$ is the transformation matrix from angular velocity $\boldsymbol{\omega}$ to Euler angle rate $\dot{\mathbf{\Phi}}$, i.e.,
\begin{equation*}
	\boldsymbol{\omega} = \mathbf{T}_{RPY} \dot{\mathbf{\Phi}}
\end{equation*}

and implement it in the function \codeword{geometric2analyticJacobian}.

\textbf{2.4 Numerical inverse kinematics (lecture E4).} Now you have all the necessary ingredients to compute the manipulator's inverse kinematics. Since we have 4-DoF, the analytical solution of the inverse kinematics problem is not straightforward, so we suggest to take the iterative approach given by the algorithm described in Fig.~\ref{fig:CLIK}. 
%
\begin{figure}[bht]
	\centering
	\includegraphics[width=8cm]{icik}
	\caption{Numerical inverse kinematics algorithm or closed-loop inverse kinematics (CLIK)}
	\label{fig:CLIK}
\end{figure}
%
Consider your task space variables to be the Cartesian space position (i.e., $x,y,z$) and the roll angle $\psi$ of the end-effector. 
Why can't the full orientation be defined in the task?
%You will need to adequately choose the rows of interest of the analytical Jacobian $\mathbf{J}_r$. 
Is $\mathbf{J}_r$ a square matrix? Is this a problem? And, can it be solved? After implementing your function, try to find the corresponding joint angles for $p = \begin{bmatrix}
	-0.5 & -0.2 & 0.5 & \frac{\pi}{3}
\end{bmatrix}$, where the first three components are the $x$, $y$, $z$ Cartesian coordinates of the end-effector and the fourth component corresponds to its roll angle $\psi$ of the end-effector.
First, implement the algorithm without line search (i.e., with constant step size $\alpha$) and then compare it with the adjustable step size. Is there any difference in the number of iterations? What is the effect of changing parameter $\alpha$ on both implementations? (you should notice that the line search might take a larger number of iterations if the initial $\alpha$ is too large) What is the influence of the initial condition?
Check that the algorithm converges to different joint configurations depending on how you initialize it.  Are the output values for the trajectory "safe"?  
Set your parameters for the iteration as follows: $\alpha = 1$, $\epsilon = 1 \times 10^{-6}$, $\gamma = 0.5$ and $\beta = 0.5$. Try to ask to reach a position of the end-effector outside of the workspace, for example, $p = \begin{bmatrix}	2.5 & -0.2 & 0.5 & \frac{\pi}{3}\end{bmatrix}$ is the error going to zero? verify that the algorithm never converges (the maximum number of iterations is reached). Using the joint angles coming out of the numerical inverse kinematics, compute the direct kinematics and obtain the error between the asked task space position and the computed one using the joint angles from the inverse kinematics. You might notice that the values of the joint variables $q$ are very large. Why is this the case? You will have to implement an "unwrapping" function to keep the joint angles between $-2\pi$ and $2\pi$. 

Also, comparing the output of the numerical inverse kinematics function with and without using the line search algorithm, what is the difference between them? 
Is one of them closer to the position that was asked to reach? You can compute the norm of the error between the position that was asked and the final position reached. Why is one closer than the other? (in this case the line search is closer to the final point) Try now increasing the maximum number of iterations to 15000 to see that the larger the number of iterations, the closer you get to $p$. Figure~\ref{fig:ik} shows the position of the robot after 10k and 15k iterations.
\begin{figure}
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{10kit}
		\caption{Position after 10k iterations}
		\label{fig:10kit}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{15kit}
		\caption{Position after 15k iterations}
		\label{fig:15kit}
	\end{subfigure}
	\caption{Positions of the robot manipulator after 10k and 15k iterations of the numerical inverse kinematics}
	\label{fig:ik}
\end{figure}

\textbf{2.5 Fifth order joint polynomial trajectory.} Now that we have a function that computes the inverse kinematics, we can use our initial joint position $\mathbf{q}_0$(defined in the file \codeword{L3_conf.py}) and the final joint position vector $\mathbf{q}_f$ (computed with our numerical inverse kinematics function) to compute a trajectory and move from one point to the other. An easy way to do so is by using a fifth-order polynomial parameterized by time to compute the position and its derivatives (i.e., velocity and acceleration) of a given joint with respect to time, i.e.,
\begin{align*}
	q_i(t) &= a_0  + a_1 t +  a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5\\
	\dot{q}_i(t) &= a_1 + 2 a_2 t + 3a_3 t^2 + 4 a_4 t^3 + 5 a_5 t^4\\
	\ddot{q}_i(t) &= 2 a_2 + 6 a_3 t + 12 a_4 t^2 + 20 a_5 t^3
\end{align*} 
we can then define a set of initial and final conditions for the joint variables $q_i$, $\dot{q}_i(t)$ and $\ddot{q}_i(t)$ and the time to define the behavior of the trajectory. Using this information we can obtain the values of the coefficients $a_i$ by solving a $6\times 6$ linear system of equations. For the initial conditions we use the $\mathbf{q}_0$ and assume that the arm starts from a no-motion condition (i.e., $\dot{\mathbf{q}}_0 = \mathbf{0}$ and $\ddot{\mathbf{q}}_0 = \mathbf{0}$). For the final conditions we can use the joint values obtained by the inverse kinematics $\mathbf{q}_f$ and again assume that the robot will come to a full stop at the end of the motion (i.e., $\dot{\mathbf{q}}_f = \mathbf{0}$ and $\ddot{\mathbf{q}}_f = \mathbf{0}$). We initialize time $t_0 = 0$ and the final time we are free to choose (the shorter the time, the faster the robot will move). With these considerations, the equations for the final and initial conditions become (per joint):
\begin{align*}
	q_0 &= a_0  \\
	q_f &= a_0  + a_1 t_f +  a_2 t_f^2 + a_3 t_f^3 + a_4 t_f^4 + a_5 t_f^5\\
	0 &= a_1 \\
	0 &= a_1 + 2 a_2 t_f + 3a_3 t_f^2 + 4 a_4 t_f^3 + 5 a_5 t_f^4\\
	0 &= 2 a_2 \\
	0 &= 2 a_2 + 6 a_3 t_f + 12 a_4 t_f^2 + 20 a_5 t_f^3
\end{align*}
which can be rewritten in matrix form as
\begin{equation*}
	\begin{bmatrix}
		q_0 \\
		q_f \\
		0 \\
		0 \\
		0 \\
		0
	\end{bmatrix} =
	\begin{bmatrix}
		1 & 0   & 0     &       0 &        0 &     0 \\
		1 & t_f & t_f^2 &   t_f^3 &    t_f^4 & t_f^5 \\
		0 &   1 &     0 &       0 &        0 &     0 \\
		0 &   1 & 2 t_f & 3 t_f^2 &  4 t_f^3 & 5 t_f^4 \\
		0 &   0 &     2 &       0 &        0 &     0 \\
		0 &   0 &     2 &   6 t_f & 12 t_f^2 & 20 t_f^3
	\end{bmatrix}
	\begin{bmatrix}
		a_0 \\
		a_1 \\ 
		a_2 \\
		a_3 \\
		a_4 \\
		a_5
	\end{bmatrix}
\end{equation*}
Then we can pre-multiply both sides of the equation by the inverse of the square matrix on the right-hand side of the equation and obtain the values for the coefficients of the polynomials.
Implement this trajectory by modifying the function \codeword{fifthOrderPolynomialTrajectory}. Plot the trajectories by un-commenting the final lines of the file \codeword{L3_kinematics.py} and see if you notice any problem. Are they violating any joint kinematic limit? How can this be prevented? 

\textbf{Extra question for lode:} The previous trajectory is simple to implement and fast to compute, however, it does not allow to set the position of the end-effector \textit{along} the trajectory. Namely, you only now for sure where the end-effector is at the beginning and the end of the motion, which in real-life scenarios can lead to potential collisions or unwanted paths. To avoid this, one can design a trajectory directly in Cartesian via parametric curves. Design a trajectory of a line in 3D Cartesian space parameterized by time and implement this on the robot. Consider that for each position given by the curve along the trajectory, you will need to compute the inverse kinematics to provide the joint values (hint: you need to do it also at the velocity and at the acceleration level). Compare the results of the trajectory with respect to the one designed in 2.5.

\section{Robot dynamics}

In this last part of the assignment, we will use the Recursive Newton-Euler Algorithm (RNEA) to compute the robot dynamics without any joint torque. We will then proceed to compute each of the terms in the dynamics equation as shown during lecture F1.2. We will start by writing our own function for the forward and backward passes of the RNEA and compute each of the terms of the dynamics equation. Then we will use the previously computed terms to obtain the forward dynamics (i.e., joint accelerations) and integrate them once to obtain the velocity and twice  for position, using a forward/explicit Euler scheme. We will then compare our results with the built-in functions of Pinocchio.

\textbf{3.1 Build the function for the RNEA (lecture F1.2).} Write a function that computes the forward and backward passes of the RNEA in the case of revolute joints, \codeword{RNEA}. We will use the following equations from lecture F1.2. So, for the forward pass we have\footnote{all quantities in both the forward and backward passes are expressed with respect to the world frame}:
\begin{align*}
	\boldsymbol{\omega}_i &= \boldsymbol{\omega}_{i-1} + \dot{\mathbf{q}}_i \mathbf{z}_i \\
%	
	\dot{\boldsymbol{\omega}}_i &= \dot{\boldsymbol{\omega}_{i-1}} + \ddot{\mathbf{q}}_i \mathbf{z}_i + \dot{\mathbf{q}}_i \boldsymbol{\omega}_{i-1} \times \mathbf{z}_i \\
%	
	\mathbf{v}_i &= \mathbf{v}_{i-1} + \boldsymbol{\omega}_{i-1} \times \mathbf{p}_{i-1,i} \\
%	
	\mathbf{a}_i &= \mathbf{a}_{i-1} + \dot{\boldsymbol{\omega}}_{i-1} \times \mathbf{p}_{i-1,i} + \boldsymbol{\omega}_{i-1} 	\times (\boldsymbol{\omega}_{i-1} \times \mathbf{p}_{i-1,i}) \\
%	
	\mathbf{a}_{ci} &= \mathbf{a}_{i} + \dot{\boldsymbol{\omega}}_{i} \times \mathbf{p}_{i,c} + \boldsymbol{\omega}_{i} 	\times (\boldsymbol{\omega}_{i} \times \mathbf{p}_{i,c})
\end{align*} 
where the last equation is the acceleration of the CoM, and the vector $\mathbf{p}_{i,c}$ is the vector from joint frame $i$ to the CoM frame. This expression will be used to compute the forces and moments along the entire chain. It is important to note that the forward pass will be computed from the base link, which is not moving and it is only subject to the acceleration of gravity (i.e., $\boldsymbol{\omega}_0 = 0$, $\dot{\boldsymbol{\omega}}_0 = 0$, $\mathbf{v}_0 = 0$ and $\mathbf{a}_0 = -\mathbf{g}$). This simplifies the computation of the forces since the acceleration of gravity is already considered in the forward pass. For the backward pass, we will begin our computation from the end-effector frame. Consider that if the end effector is performing free-motion, then the forces and moments are equal to zero (i.e., $\mathbf{f}_{ee} =0$ and $\mathbf{m}_{ee} = 0$), however, if the end-effector is in contact with an object, a measurement or approximation of the forces and moments is needed. The backward pass equations for the moments and forces are
\begin{align*}
	\mathbf{f}_i &= \mathbf{f}_{i+1} + \mathbf{m}_i\mathbf{a}_{ci} \\
	\mathbf{m}_i &= \mathbf{m}_{i+1} - \mathbf{p}_{i-1,i} \times \mathbf{f}_i + \mathbf{p}_{i,i+1} \times \mathbf{f}_{i+1} + \mathbf{I}_i \dot{\boldsymbol{\omega}}_i + \boldsymbol{\omega}_i  \times \mathbf{I}_i \boldsymbol{\omega}_i
\end{align*}
Remember that all quantities are expressed with respect to the world, so you will need to provide appropriate transformations for the parameter vectors and matrices (e.g., the position of the CoM $\mathbf{p}_{ci}$ and the inertia tensor $\mathbf{I}_i$). The function \codeword{RNEA} should receive as input arguments the gravity vector $\mathbf{g}_0$ ($\begin{bmatrix}
	0 & 0 & -9.81
\end{bmatrix}^{\top}$), the vector of current joint positions $\mathbf{q}$, the vector of current joint velocities $\dot{\mathbf{q}}$ and the vector of current joint accelerations $\ddot{\mathbf{q}}$, i.e.,
\codeword{RNEA(g0,q,qd,qdd)}. 

\textbf{3.2 Compute each of the terms of the dynamics equation (lecture F1.2). } Create functions to compute the joint space inertia matrix $\mathbf{M}$, the vector of Coriolis and centrifugal terms $\mathbf{C}$ and the vector of gravitational force $\mathbf{g}$. Remember that the RNEA function previously written can be used to obtain all of these terms by setting some quantities to 0. In essence, compute the gravity vector through the previous function by setting its arguments as \codeword{RNEA(g0,q,0,0)}, the vector of Coriolis and centrifugal forces with \codeword{RNEA(0,q,qd,0)} and each of the columns of the joint space inertia matrix with \codeword{RNEA(0,q,0,ei)}, where \codeword{ei} is a vector to select the i-th column of $\mathbf{M}$.

\textbf{3.3 Compute the robot forward dynamics (lecture F1.2).} Now that the equations of motion can be computed, simulate the robot dynamics under zero joint torque. To do this, you need to obtain the joint acceleration based on the equations of motion, namely:
%
\begin{equation*}
	\ddot{\mathbf{q}} = \mathbf{M}^{-1} (\boldsymbol{\tau} - \mathbf{g} - \mathbf{C})
\end{equation*}

with $\boldsymbol{\tau} = 0$ (for the time being). 

\textbf{3.4 Simulate the robot dynamics using a forward Euler scheme (lecture F1.2).} With the previously computed joint acceleration, we can integrate once to obtain joint velocity and twice for position. Implement an improved forward/explicit Euler integration scheme in the included \codeword{while} loop in the provided main file to run your visualization \codeword{LOCOSIM/robot_control/L1_2_dynamics.py} by using the following equations:
\begin{align*}
	\dot{\mathbf{q}}(t  + \delta t) &= \dot{\mathbf{q}} (t) + \ddot{\mathbf{q}}(t) \delta t \\
	\mathbf{q}(t +\delta t) &= \mathbf{q}(t) + \dot{\mathbf{q}} (t) \delta t + \frac{\delta t^2}{2}\ddot{\mathbf{q}}(t)
\end{align*}
 where $\delta t$ is the time step of our simulation. Check the visualizer, you will see the robot falling but never stopping. Why? Is this realistic? What can be done to stop the motion after a while?
 
\textbf{3.4 Add a damping term to the equation.} The robot is not stopping since there is no friction or damping that allows the joint velocities to come to a stop. Implement a damping term by defining $\mathbf{\tau}$ as
\begin{equation*}
	\boldsymbol{\tau} = -b\dot{\mathbf{q}}
\end{equation*} 
where $b$ is the damping coefficient of the joints. For now, we keep $b$ as a scalar, however, you can set different damping coefficients for each of the joints. Try different values of $b$ and visualize the behavior of the robot changing.

\textbf{3.5 Compare results against Pinocchio.} Compute the terms of the dynamics equation $\mathbf{M}$, $\mathbf{C}$ and $\mathbf{g}$ using the built in functions from Pinocchio. To compute $\mathbf{g}$ use the following function: \codeword{robot.gravity(q)}, which takes as only argument the vector of joint positions. To compute $\mathbf{M}$ use: \codeword{robot.mass(q, False)}\footnote{For the functions of the mass and nonlinear terms the second argument is a Boolean related to the update of the joint variables, in our case we are keeping it as false since we are updating the joint states manually}. In the case of vector $\mathbf{C}$, Pinocchio only provides the sum $\mathbf{h} = \mathbf{C} +  \mathbf{g}$ through the function: \codeword{robot.nle(q, qd, False)}. Run again the simulation using Pinocchio and verify that the outputs of the function that you wrote coincides with those of the built-in functions. Now remove entirely the implementation with your functions and visualize the robot falling. You will notice that the robot is moving slightly faster that with your own implementation. Why is this the case? (Ans. This is mainly due to the fact that Pinocchio is implemented in C++ but used in Python through bindings and because our implementation is done with respect to the world frame, whereas in Pinocchio it is implemented with respect to the link frame, and this results in "sparser" matrix multiplications).



\end{document}



